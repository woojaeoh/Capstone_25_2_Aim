"""
전처리 전용 (통합 실행)
로직(유지):
  - 모든 줄을 '한 줄'로 병합 → 맞춤법/띄어쓰기 교정
  - '목표주가/목표가/TP(단어경계)' → 'num' 치환
  - 숫자 → 'num' 치환

부수 로직(기존 스타일 유지):
  - 매수/매도 각각 최신 LIMIT_PER_CLASS개 선택
  - 세이프가드: A) FULL → B) 교정만 → C) 병합만 → D) 기본정리만 → E) 스킵
  - 출력: preprocessed.json, preprocess_debug.tsv

입력 폴더:
  ~/Desktop/매도 , ~/Desktop/매수   (각 폴더의 .txt)
출력:
  ~/Desktop/결과_매수매도_학습/preprocessed.json

"""

import re, json
from pathlib import Path

# ===== 경로/설정 =====
HOME = Path.home()
NEG_DIR = HOME / "Desktop" / "매도"
POS_DIR = HOME / "Desktop" / "매수"
OUT_DIR = HOME / "Desktop" / "결과_매수매도_학습"
OUT_DIR.mkdir(parents=True, exist_ok=True)

LIMIT_PER_CLASS = 2350    
MIN_CHARS_AFTER  = 80

# ===== 인코딩 스마트 리더 =====
def read_text_smart(p: Path) -> str:
    encodings = ["utf-8", "utf-8-sig", "cp949", "euc-kr", "iso-8859-1"]
    for enc in encodings:
        try:
            return p.read_text(encoding=enc)
        except Exception:
            continue
    try:
        return p.read_bytes().decode("utf-8", errors="ignore")
    except Exception:
        return ""

# ===== 기본 정리(개행은 나중에 제거) =====
def basic_trim_keep_newlines(t: str) -> str:
    t = re.sub(r'[\u00A0\u200B-\u200D]+', ' ', t)       
    t = t.replace('\r\n', '\n').replace('\r', '\n')     
    t = re.sub(r'[ \t]+', ' ', t)                   
    return t.strip()

# ===== 모든 줄을 '한 줄'로 병합 =====
def merge_all_to_one_line(text: str) -> str:
    t = basic_trim_keep_newlines(text)
    t = t.replace('\n', '')                           
    t = re.sub(r'\s+', ' ', t).strip()
    return t

# ===== 맞춤법/띄어쓰기 교정 =====
def correct_text_single_line(text: str) -> str:
    txt = text
    try:
        from pykospacing import Spacing
        txt = Spacing()(txt)
    except Exception:
        pass
    try:
        from hanspell import spell_checker
        res = spell_checker.check(txt)
        if hasattr(res, "checked") and isinstance(res.checked, str):
            txt = res.checked
    except Exception:
        pass
    return txt.strip()

# ===== '목표가/TP' → 'num' 치환 (tp는 단어 경계) =====
_KOR_TP = r'(?:목\s*표\s*주\s*가|목\s*표\s*가)'
_TP_WORD = r'(?<![A-Za-z0-9])tp(?![A-Za-z0-9])'
TP_MASK_PATTERN = re.compile(
    rf'(?P<kw>{_KOR_TP}|{_TP_WORD})(?P<pp>은|는|이|가|을|를|와|과|로|으로)?',
    re.IGNORECASE
)

def _particle_fix(pp: str) -> str:
    if not pp:
        return ''
    mapping = {'는': '은', '가': '이', '를': '을', '와': '과', '로': '으로'}
    return mapping.get(pp, pp)

def mask_target_keywords_to_num(text: str) -> str:
    def _repl(m: re.Match) -> str:
        pp = m.group('pp') or ''
        return 'num' + _particle_fix(pp)
    return TP_MASK_PATTERN.sub(_repl, text)

# ===== 숫자 → 'num' 치환 =====
NUM_PATTERN_TO_NUM = re.compile(
    r"""(?x)
    (?:[+-]?\d{1,3}(?:,\d{3})+(?:\.\d+)?%?)|
    (?:[+-]?\d+\.\d+%?)|
    (?:[+-]?\d+%?)|
    (?:\d+\s*만원|\d+\s*억원|\d+\s*조원|\d+\s*원)
    """
)
def mask_numbers_to_num(text: str) -> str:
    return NUM_PATTERN_TO_NUM.sub("num", text)

# ===== 최신 날짜순 N개 선택 =====
def read_latest_txts(dirpath: Path, limit: int):
    files = [p for p in dirpath.glob("*.txt") if p.is_file()]
    def extract_date(fname: str):
        nums = re.findall(r"\d{8}", fname)
        return int(nums[-1]) if nums else 0
    files.sort(key=lambda x: extract_date(x.name), reverse=True)
    files = files[:limit]
    print(f"[선택] {dirpath.name}: {len(files)}개 (최신순)")
    texts, names = [], []
    for p in files:
        raw = read_text_smart(p)
        if raw is None:
            raw = ""
        texts.append(raw)
        names.append(p.name)
    return texts, names

# ===== 전처리(세이프가드 포함) =====
def preprocess_full(doc: str) -> str:
    merged = merge_all_to_one_line(doc)
    corrected = correct_text_single_line(merged) if merged else ""
    if not corrected:
        corrected = merged
    step_tp = mask_target_keywords_to_num(corrected)
    final_text = mask_numbers_to_num(step_tp).strip()
    return final_text

def preprocess_with_safeguard(doc: str) -> str:
    # A) FULL
    t = preprocess_full(doc)
    if len(t) >= MIN_CHARS_AFTER:
        return t
    # B) 교정만
    merged = merge_all_to_one_line(doc)
    only_correct = correct_text_single_line(merged) if merged else ""
    if len(only_correct) >= MIN_CHARS_AFTER:
        return only_correct
    # C) 병합만
    if len(merged) >= MIN_CHARS_AFTER:
        return merged
    # D) 기본정리만(개행 제거 X)
    basic = basic_trim_keep_newlines(doc)
    if len(basic) >= MIN_CHARS_AFTER:
        return basic
    # E) 그래도 짧으면 빈 문자열
    return ""

def main():
    # 0) 데이터 로드(최신 N개씩)
    neg_raw, neg_names = read_latest_txts(NEG_DIR, limit=LIMIT_PER_CLASS)
    pos_raw, pos_names = read_latest_txts(POS_DIR, limit=LIMIT_PER_CLASS)

    X_raw = neg_raw + pos_raw
    y     = [0]*len(neg_raw) + [1]*len(pos_raw)
    names = neg_names + pos_names

    # 1) 전처리 + 세이프가드
    X_clean, y_clean, kept_names, strat = [], [], [], []
    skipped = 0

    for doc, label, fname in zip(X_raw, y, names):
        t = preprocess_full(doc)
        s = "FULL"
        if len(t) < MIN_CHARS_AFTER:
            t = correct_text_single_line(merge_all_to_one_line(doc))
            s = "CORRECT_ONLY"
        if not t or len(t) < MIN_CHARS_AFTER:
            t = merge_all_to_one_line(doc)
            s = "MERGE_ONLY"
        if not t or len(t) < MIN_CHARS_AFTER:
            t = basic_trim_keep_newlines(doc)
            s = "BASIC_ONLY"

        if not t or len(t) < MIN_CHARS_AFTER:
            skipped += 1
            continue

        X_clean.append(t)
        y_clean.append(label)
        kept_names.append(fname)
        strat.append(s)

    print(f"[세이프가드] 최종 유지 {len(X_clean)}개 / 스킵 {skipped}개 (기준: {MIN_CHARS_AFTER}자)")

    # 2) 저장
    (OUT_DIR / "preprocessed.json").write_text(
        json.dumps({"texts": X_clean, "labels": y_clean}, ensure_ascii=False, indent=2),
        encoding="utf-8"
    )

    with open(OUT_DIR / "preprocess_debug.tsv", "w", encoding="utf-8") as f:
        f.write("filename\tstrategy\tlen\n")
        for txt, s, nm in zip(X_clean, strat, kept_names):
            f.write(f"{nm}\t{s}\t{len(txt)}\n")

    print(f"[저장 완료] {OUT_DIR / 'preprocessed.json'}")
    print(f"[디버그] {OUT_DIR / 'preprocess_debug.tsv'}")

if __name__ == "__main__":
    main()
